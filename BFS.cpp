//BFS는 '맹목적인 탐색'을 할 때 사용
//너비 우선 탐색은 '최단 경로'를 찾아 준다는 점에서 최단 길이를 보장해야 할 떄 많이 사용
//흔히 미로찾기 와 같은 알고리즘에서 사용
//필요한 준비물은 큐이다. 먼저들어 온것을 먼저 내보낸다는 특징 떄문에 bfs를 가능 하게 해주는 특징이 있다.
//맨처음에 시작 노드(Start Node)를 큐에 삽입하면서 시작합니다.
//또한 시작 노드를 방문 했다고 '방문처리'를 해주도록 합니다.


#include<iostream> //C++ stl library 쓸거기떄문에 전용 헤더
#include<queue>
#include<vector>//벡터 이용해서 데이터를 저장할 수 있게 만들어준다.

using namespace std;

int number =7; //기본적으로 다뤄본 원소 갯수7개
int c[7]; //방문 체크를 위한 방문 했다 의미를 위한 checked배열
vector<int> a[8]; //7+1만큼 vector가 들어갈 배열 만들어줌 각 노드의 인덱스가 1부터 처리 될수 있도록 1~7까지 인덱스를 처리할 수 있게 8개의 의미를 둔것

//BFS 알고리즘
/*
1. 큐에서 하나의 노드를 꺼냅니다.
2. 해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입합니다.
*/
//이를 1,2번을 반복해준다.
void bfs(int start){
    queue<int> q; //하나의 큐를 만들어준다.
    q.push(start); //큐에 시작점을 넣어줍니다.
    c[start] = true;  //방문 처리를 해줄 것이다.
    while(!q.empty()){ //이제 반복 수행을 하면 된다. 큐가 빌떄 까지 반복
        int x = q.front(); //큐에서 하나를 꺼내서 변수x에 담아줍니다.
        q.pop(); 
        printf("%d ", x);//이 변수 x를 출력해줍니다.
        for(int i=0;i<a[x].size();i++){ //i=0부터 현재 queue에서 꺼낸 원소와 인접한 원소 노드들을 하나씩 방문하면서 
            int y = a[x][i]; //방문을 한 상태라면 꺼내고
            if(!c[y]){ // 방문을 하지 않은 상태라면
                q.push(y); //큐에 담아주면 됩니다. 
                c[y] = true; //그 다음에 방문 처리를 해준다.
            }
        }
    }
}

int main(void){
    a[1].push_back(2);
    a[2].push_back(1);

    a[1].push_back(3);
    a[3].push_back(1);

    a[2].push_back(3);
    a[3].push_back(2);

    a[2].push_back(4);
    a[4].push_back(2);
    
    a[2].push_back(5);
    a[5].push_back(2);

    a[3].push_back(6);
    a[6].push_back(3);

    a[3].push_back(7);
    a[7].push_back(3);

    a[4].push_back(5);
    a[5].push_back(4);

    a[6].push_back(7);
    a[7].push_back(6);
    
    bfs(1);

    return 0;
}
//큐에서 꺼낸 순서가 1,2,3,4,5,6,7이다.
//이렇게 거리가먼 4,5,6,7은 마지막에 탐색하게 된다.
//거리가 가까운것 먼저 탐색이 이루어진다. 거리가 1인것 2,3먼저 탐색
//1과 가까운 순서대로 탐색을 하게 된다.
//이제 이러한 너비 우선 탐색은 자체로 큰 의미가 없다
//실제로 다른 알고리즘에 적용된다는 것이 핵심입니다.
//bfs는 탐색방법중 하나일 뿐 이곳저곳에 다양하게 응용이 될 것이다.
