//깊이 우선 탐색은 너비우선 탐색과 마찬가지로 맹목적으로 각 노드 탐색할떄 주로 사용됩니다.
//너비 우선 탐색에서는 Queue가 사용 되었다면
//깊이 우선 탐색에서는 Stack을 사용하면 됩니다.
//더불어 스택을 사용하지 않아도 구현이 가능하다는 특징이 있습니다.
//컴퓨터 구조는 항상 스택의 원리를 사용하기 떄문입니다.
//컴퓨터 자체가 스택프레임이라고 해서 스택 원리가 사용되기 떄문에 스택 이용하지않고 재귀함수만으로도 깊이우선 탐색이 가능하다.
//재귀함수를 쓰는 이유는 stack이라는 컴퓨터 구조 처럼 쓰고 넣고를 반복하는 구조이기떄문에 사용하면 좋다.
//소문난 칠공주
//결국 경로를 저장하고 있다가 중복되는 경로이면 답에 포함시키지 않아야 한다.
//그래서 비트마스크로 방문한 모든 경로를 가지고 있어야 한다.
//dfs 백트래킹으로 풀 수 없는 문제여서 십자가 모양은 dfs가 안된다.
//전체 25개를 순열로 푼다고?

/* 1) 25개 중 7개를 선택하는 순열을 생성하고 7개를 구한다.
    2) 이다솜파가 4명이상인지 검사한다.
     3) 4명 이상이면 플러드필(bfs,dfs 아무거나)를 사용해서 7개가 인접한지 검사한다.?-> 그냥 인접한지만 검사하면 되는건가 -> 4명이상만 체크하면 되서?
      -> 조건 3개를 모두 통과하면 경우의 수를 증가시킨다.
      25개중 7개를 선택해서 4명이상일떄 이다솜그룹인지 확인하고 이다솜 그룹('S')이 7명이면 cnt++를 해준다는게 끝인거 같다. 
*/
#include<iostream>
#include<vector>

using namespace std;

char map[5][5];
bool visit[1 << 25]; //방문한 경로 체크
int dx[] = {1,0,-1,0};
int dy[] = {0,1,0,-1};
int ans =0;

//경우의 수가 중복되게 된다.
void dfs(int depth, int cnt, int route){ //route는 지금까지 온 경로체크
    if(depth == 7) {
        if(cnt >=4)
            ans++;
            return;
    }
    for(int k =0;k<25;k++){
        //지금까지 왔던 경로가 맞는지 체크하기
        if((route & (1 << k)) == 0) 
            continue;
            //이거는 좌표를 구하기 위한 숫자 어차피 5x5 25개니까 (1,2)구할려면 몫과 나머지를 구해야 합니다.
        int x = k / 5;
        int y = k % 5;

        for(int i=0; i<4; i++){
            int nx = x + dx[i];
            int ny = y + dy[i];

            if(nx < 0 || ny <0 || nx >=5 || ny >=5)
            continue;

        //이거 왜 하는 건지 모르겠음
            int num = nx * 5 + ny;

            //방문 했었던 경로면 skip
            if(visit[route|(1<<num)])
            continue;
            
            //방문한 노드는 1로 표시를 해준다.
            visit[route | (1 << num)] = 1;
            
            //만약에 map에 S 이다솜양이 있으면
            if(map[nx][ny] == 'S')
            dfs(depth + 1, cnt + 1, route | (1<<num));
            //S 이다솜 양이 없으면 cnt +1을 해주지 않고 그냥 그대로 cnt로 내보낸다
            else
            dfs(depth + 1, cnt, route | (1<<num));

        }
    }
}
int main(){
    for(int i=0;i<5;i++)
    cin >> map[i];
    for(int i=0;i<5;i++){
        for(int j=0;j<5;j++){
            //이게 방문했으면 1인건가?
            visit[1 << (i * 5 + j)] = 1;
            dfs(1, map[i][j] == 'S', 1 << (i * 5 + j));
        }
    }
    cout << ans;
}

/*
//총 7개의 노드가 각각 인접한 노드를 가질수 있도록 만들어 주었다.
void dfs(int x){
    if(c[x]) return; //현재 그 노드를 방문했다면 이렇게 return해줘서 바로 함수를 끝낼 수 있도록 해준다.
    c[x] = true;//그 노드를 처음 방문하는 거라면 이렇게 방문 처리를 해주면 된다.
    cout << x << ' '; //이제 그 노드를 출력할 수 있게 해주면 된다.
    //인접 노드를 하나씩 방문을 하면서 
    for(int i=0;i<a[x].size();i++){
        //인접 노드를 대상으로 해서 dfs를 수행하면 된다.
        int y = a[x][i];
        dfs(y); //계속해서 자기와 인접한 노드를 반복한다.dfs를 수행하면서 깊이우선탐색을 안정적을 사용하게 됨.
    }
}
//DFS는 다음과 같은 간단한 알고리즘에 따라서 작동 합니다.
/*
1. 스택의 최상단 노드를 확인합니다.(가장 마지막에 들어온 노드)
2. 최상단 노드에게 방문하지 않은 인접 노드가 있으면 그 노드를 스택에 넣고 방문처리 합니다.
3. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 뻅니다.
인접 노드 중에서 가장 작은 (낮은) 숫자가 있는 노드로 작성
*/
//차곡차곡쌓이는 스택프레임이랑 같은 원리이기떄문에 넣고 뺴고가 같은 의미
/*
void dfs(int x){
    if(c[x]) return;
    c[x] = true;
    cout << x << ' ';
    for(int i=0;i<a[x].size();i++){
        int y = a[x][i];
        dfs(y);
    }
}
*/
/*
int main(void){
    a[1].push_back(2);
    a[2].push_back(1);

    a[1].push_back(3);
    a[3].push_back(1);

    a[2].push_back(3);
    a[3].push_back(2);

    a[2].push_back(4);
    a[4].push_back(2);
    
    a[2].push_back(5);
    a[5].push_back(2);

    a[3].push_back(6);
    a[6].push_back(3);

    a[3].push_back(7);
    a[7].push_back(3);

    a[4].push_back(5);
    a[5].push_back(4);

    a[6].push_back(7);
    a[7].push_back(6);
    
    dfs(1);
//삿포로,일본계획,
    return 0;
}
*/
//이 dfs를 가지고 그래프 알고리즘을 활용할 수 있다
//이 자체로는 큰 의미가 없고 DFS를 활용해서 문제를 해결하고자 하는 것에 주안점이 두어져 있다.
//작동 원리만 빠삭하게 알아두자
//또한 스택을 직접 사용하지 않고 재귀함수를 이용해 간략하게 함수를 구현할 수 있따.
//스택에서 꺼낸 순서는  1,2,3,6,7,4,5이다.(3,6,7)먼저 돌고 (2,4,5)나중에 돈다.